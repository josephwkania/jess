
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>jess package &#8212; jess 0.1.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="jess-package">
<h1>jess package<a class="headerlink" href="#jess-package" title="Permalink to this headline">¶</a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="jess.scipy_cupy.html">jess.scipy_cupy package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="jess.scipy_cupy.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="jess.scipy_cupy.html#module-jess.scipy_cupy.stats">jess.scipy_cupy.stats module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jess.scipy_cupy.html#module-jess.scipy_cupy">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-jess.JESS_filters">
<span id="jess-jess-filters-module"></span><h2>jess.JESS_filters module<a class="headerlink" href="#module-jess.JESS_filters" title="Permalink to this headline">¶</a></h2>
<p>The repository for all my filters</p>
<dl class="py class">
<dt class="sig sig-object py" id="jess.JESS_filters.FilterMaskResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">FilterMaskResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percent_masked</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.FilterMaskResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<p>dynamic_spectra - Dynamic Spectra with RFI filtered
mask - Boolean mask
percent_masked - The percent masked</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters.FilterMaskResult.dynamic_spectra">
<span class="sig-name descname"><span class="pre">dynamic_spectra</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#jess.JESS_filters.FilterMaskResult.dynamic_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters.FilterMaskResult.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#jess.JESS_filters.FilterMaskResult.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters.FilterMaskResult.percent_masked">
<span class="sig-name descname"><span class="pre">percent_masked</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.float64</span></em><a class="headerlink" href="#jess.JESS_filters.FilterMaskResult.percent_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="jess.JESS_filters.FilterResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">FilterResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percent_masked</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.FilterResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<p>dynamic_spectra - Dynamic Spectra with RFI filtered
percent_masked - The percent masked</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters.FilterResult.dynamic_spectra">
<span class="sig-name descname"><span class="pre">dynamic_spectra</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#jess.JESS_filters.FilterResult.dynamic_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters.FilterResult.percent_masked">
<span class="sig-name descname"><span class="pre">percent_masked</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.float64</span></em><a class="headerlink" href="#jess.JESS_filters.FilterResult.percent_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.anderson_calculate_values">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">anderson_calculate_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.anderson_calculate_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a Anderson Darling test on a Fits/Filterbank</p>
<dl>
<dt>Args:</dt><dd><p>yr_file: Your object</p>
<p>window: window size for the test</p>
<dl class="simple">
<dt>time_median_kernel: remove baseline by subtracting a running median</dt><dd><p>of time_median_kernel length long. Default is
no subtraction</p>
</dd>
<dt>returns:</dt><dd><p>array of anderson darling values for each window.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.autocorrelation_calculate_values">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">autocorrelation_calculate_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.autocorrelation_calculate_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Autocorrelation for blocks of length window.</p>
<dl>
<dt>Args:</dt><dd><p>yr_file: The Your object for a FITS/fil file to process</p>
<p>window: window length in number of time samples</p>
<dl class="simple">
<dt>time_median_kernel: Detrend in time by subtracting a smoothed running</dt><dd><p>median, smoothed bt time_median_kernel</p>
</dd>
</dl>
<p>bandpass_kernel: bandpass kernel to smooth bandpass</p>
</dd>
<dt>Returns:</dt><dd><p>Autocorrelation values for each block in the file</p>
</dd>
<dt>Notes:</dt><dd><p>Not sure what the best test for autocorrelation.</p>
<p><a class="reference external" href="https://arxiv.org/pdf/2108.12434.pdf">https://arxiv.org/pdf/2108.12434.pdf</a> uses the absolute magnitude of
of a one sample delay.</p>
<p>The Durbin-Watson statistic also uses the first lag
<a class="reference external" href="https://en.wikipedia.org/wiki/Durbin%E2%80%93Watson_statistic">https://en.wikipedia.org/wiki/Durbin%E2%80%93Watson_statistic</a></p>
<dl class="simple">
<dt>I’ve tried some other tests,</dt><dd><ul class="simple">
<li><p>the sum of the absolute values of all the correlations</p></li>
<li><p>(std - iqr) to look for outliers</p></li>
<li><p>the absolute value of the first lag</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.central_limit_masker">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">central_limit_masker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_values</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.central_limit_masker" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the central limit theorem to look for outliers in each subband.
When looking at a large amount of values, the central limit theorem
says the values should start to be Guassian distributed. We can use
this to flag outliers.</p>
<p>Using subbands we can take into account changes in sensitively across
the band/cavity filters.</p>
<dl>
<dt>Args:</dt><dd><p>test_values: the values from a statistical test</p>
<p>window: the window size of the test</p>
<p>sigma: sigma at which to flag values</p>
<p>num_subbands: number of subbands</p>
</dd>
<dt>return:</dt><dd><p>bool array with outliers get set as true, this will be the same
size as the data.</p>
</dd>
<dt>notes:</dt><dd><p>see “Spectral Kurtosis-Based RFI Mitigation for CHIME”
<a class="reference external" href="https://arxiv.org/abs/1808.10365">https://arxiv.org/abs/1808.10365</a></p>
<p>and</p>
<p>“High cadence kurtosis based RFI excision for CHIME”
<a class="reference external" href="https://open.library.ubc.ca/soa/cIRcle/collections/ubctheses/24/items/1.0394838?o=5">https://open.library.ubc.ca/soa/cIRcle/collections/ubctheses/24/items/1.0394838?o=5</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.dagostino_calculate_values">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">dagostino_calculate_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.dagostino_calculate_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a D’Agostino test on a Fits/Filterbank</p>
<dl>
<dt>Args:</dt><dd><p>yr_file: Your object</p>
<p>window: window size for the test</p>
<dl class="simple">
<dt>time_median_kernel: remove baseline by subtracting a running median</dt><dd><p>of time_median_kernel length long. Default is
no subtraction</p>
</dd>
<dt>returns:</dt><dd><p>array of D’Agostino values for each window.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.entropy_calculate_values">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">entropy_calculate_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.entropy_calculate_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Shannon Entropy for blocks of length window.</p>
<dl>
<dt>Args:</dt><dd><p>yr_file: The Your object for a FITS/fil file to process</p>
<p>window: window length in number of time samples</p>
<dl class="simple">
<dt>time_median_kernel: Detrend in time by subtracting a smoothed running</dt><dd><p>median, smoothed bt time_median_kernel</p>
</dd>
</dl>
<p>bandpass_kernel: bandpass kernel to smooth bandpass</p>
</dd>
<dt>Returns:</dt><dd><p>Shannon values for each block in the file</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.fft_mad">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">fft_mad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitter:</span> <span class="pre">object</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">poly_fitter&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bad_chans:</span> <span class="pre">typing.Optional[numpy.ndarray]</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.fft_mad" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the real FFT of the dynamic spectra along the time axis
(a FFT for each channel). Then take the absolute value, this
gives the magnitude of the power &#64; each frequency.</p>
<p>Then run the MAD filter along the freqency axis, this looks for
outliers in the in the spectra. Narrow band RFI will only be
in a few channels, add will be flagged.</p>
<p>This mask is then used to flag the complex FFT by setting the
flagged points to zero. The first row is excluded because this
is the powers for each channel. This could be zero, but it has
so effect, and keeping it at its current value keeps the
bandpass smooth.</p>
<p>The masked FFT is then inverse real fft back. Data is clip to
min/max for the given input data type and returned as that
data type.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: spectra block with time on the vertical axis,</dt><dd><p>and freq on the horizontal</p>
</dd>
</dl>
<p>chans_per_subband: number of frequency samples to calculate MAD</p>
<p>sigma: cutoff sigma</p>
<p>time_median_size: the length of the median filter to run in time</p>
<p>chans_per_fit: polynomial/spline knots per channel to fit the bandpass</p>
<p>fitter: which fitter to use, see jess.fitters for options</p>
<dl class="simple">
<dt>bad_chans: list of bad channels - these have all information</dt><dd><p>removed except for the power</p>
</dd>
</dl>
<p>return_same_dtype: return the same data type as given</p>
<p>return_mask: return the bool mask of flagged frequencies</p>
</dd>
<dt>Returns:</dt><dd><p>Dynamic Spectrum with narrow band perodic RFI removed.</p>
<p>(optional) bool mask of frequencies where bad=True</p>
</dd>
</dl>
<p>See:</p>
<blockquote>
<div><p>For MAD
<a class="reference external" href="https://github.com/rohinijoshi06/mad-filter-gpu">https://github.com/rohinijoshi06/mad-filter-gpu</a></p>
<p>For FFT cleaning
<a class="reference external" href="https://arxiv.org/abs/2012.11630">https://arxiv.org/abs/2012.11630</a> &amp; <a class="reference external" href="https://github.com/ymaan4/RFIClean">https://github.com/ymaan4/RFIClean</a></p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.filter_weights">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">filter_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric:</span> <span class="pre">typing.Callable</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">median&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass_smooth_length:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_sigma:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.6666666666666666</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_sigma:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">30</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.filter_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes weights based on low values of some meteric.
This is designed to ignore bandpass filters or tapers
at the end of the bandpass.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra - 2D dynamic spectra with time on the</dt><dd><p>vertical axis</p>
</dd>
</dl>
<p>metric - The statistic to sample.</p>
<dl class="simple">
<dt>bandpass_smooth_length - length of the median filter to</dt><dd><p>smooth the bandpass</p>
</dd>
</dl>
<p>sigma_cut - Cut values below (standard deviation)*(sigma cut)</p>
<dl class="simple">
<dt>smooth_sigma - Gaussian filter smoothing sigma. If =0, return</dt><dd><p>the mask where True=good channels</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Bandpass weights for sections of spectra with low values.
0 where the value is below the threshold and 1 elsewhere,
with a Gaussian taper.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.iterative_mad">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">iterative_mad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">filter_weight_args</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.iterative_mad" title="Permalink to this definition">¶</a></dt>
<dd><p>Interatively clean a chunk of dynamic spectra.
If filter_weight_args is not <cite>None</cite>, masks channels that
are unlickely to have signal. MAD and MAD FFT are run.
Then the channels are decimated by <cite>factor</cite> and MAD is run
again, decreasing <cite>chans_per_subband</cite> by <cite>factor</cite>. This
is repeated until <cite>factor</cite> channels, when the mean is taken</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: a dynamic spectra with time on the vertical axis,</dt><dd><p>and freq on the horizontal</p>
</dd>
</dl>
<p>factor - Factor to reduce each iteration</p>
<p>chans_per_subband: Number of channels to calculate the MAD</p>
<p>sigma: sigma which to reject outliers</p>
<p>flatten_to: the median of the output data</p>
<p>time_median_size: the length of the median filter to run in time</p>
<dl class="simple">
<dt>filter_weight_args: Passed to <cite>filter_weights</cite>, if <cite>None</cite> no</dt><dd><p>filter of channels.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Cleaned Time Series</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.jarque_bera_calculate_values">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">jarque_bera_calculate_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.jarque_bera_calculate_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Jaque Bera statistic.
Use robust ways to normalize the blocks.</p>
<dl>
<dt>Args:</dt><dd><p>yr_file: The Your object for a FITS/fil file to process</p>
<p>window: window length in number of time samples</p>
<dl class="simple">
<dt>time_median_kernel: Detrend in time by subtracting a smoothed running</dt><dd><p>median, smoothed bt time_median_kernel</p>
</dd>
</dl>
<p>bandpass_kernel: bandpass kernel to smooth bandpass</p>
</dd>
<dt>Returns:</dt><dd><p>Jarque Bera statistic</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.kurtosis_calculate_values">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">kurtosis_calculate_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.kurtosis_calculate_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Kurtosis for blocks of length window.</p>
<dl>
<dt>Args:</dt><dd><p>yr_file: The Your object for a FITS/fil file to process</p>
<p>window: window length in number of time samples</p>
<dl class="simple">
<dt>time_median_kernel: Detrend in time by subtracting a smoothed running</dt><dd><p>median, smoothed bt time_median_kernel</p>
</dd>
</dl>
<p>bandpass_kernel: bandpass kernel to smooth bandpass</p>
</dd>
<dt>Returns:</dt><dd><p>Kurtosis</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.lilliefors_calculate_values">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">lilliefors_calculate_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.lilliefors_calculate_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Lilliefors statistic.
Use robust ways to normalize the blocks.</p>
<dl>
<dt>Args:</dt><dd><p>yr_file: The Your object for a FITS/fil file to process</p>
<p>window: window length in number of time samples</p>
<dl class="simple">
<dt>time_median_kernel: Detrend in time by subtracting a smoothed running</dt><dd><p>median, smoothed bt time_median_kernel</p>
</dd>
</dl>
<p>bandpass_kernel: bandpass kernel to smooth bandpass</p>
</dd>
<dt>Returns:</dt><dd><p>Lilliefors statistic</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.mad_spectra">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">mad_spectra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitter:</span> <span class="pre">object</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">poly_fitter&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.mad_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Median Absolute Deviations along the spectral axis
(i.e. for each time sample across all channels)</p>
<dl>
<dt>Args:</dt><dd><p>dynamic_spectra: dynamic spectra with time on the vertical axis,
and freq on the horizontal</p>
<p>chans_per_subband: number of channels to calculate the MAD</p>
<p>sigma: cutoff sigma</p>
<p>chans_per_fit: polynomial/spline knots per channel to fit the bandpass</p>
<p>fitter: which fitter to use, see jess.fitters</p>
<p>return_same_dtype: return the same data type as given</p>
<p>return_mask: return the mask</p>
</dd>
<dt>Returns:</dt><dd><p>Dynamic Spectrum with values clipped</p>
</dd>
<dt>See:</dt><dd><p><a class="reference external" href="https://github.com/rohinijoshi06/mad-filter-gpu">https://github.com/rohinijoshi06/mad-filter-gpu</a></p>
</dd>
<dt>Notes:</dt><dd><p>mad_spectra_flat has better excision performance, you should consider that
unless you need to keep the bandpass shape</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.mad_spectra_flat">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">mad_spectra_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_time_detrend</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.mad_spectra_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Median Absolute Deviations along the spectral axis
(i.e. for each time sample across all channels). This flattens the
data by subtracting the rolling median of median of time and frequencies.
It then calculates the Median Absolute Deviation for every frame channels.
Outliers are removed based on the assumption of Gaussian data. The dynamic
spectra is then detrended again, masking the outliers. This process is then
repeated again. The data is returned centerned around flatten_to with removed
points set as flatten_to.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: a dynamic spectra with time on the vertical axis,</dt><dd><p>and freq on the horizontal</p>
</dd>
</dl>
<p>chans_per_subband: number of channels to calculate the MAD</p>
<p>sigma: sigma which to reject outliers</p>
<p>flatten_to: the median of the output data</p>
<p>time_median_size: the length of the median filter to run in time</p>
<p>return_same_dtype: return the same data type as given</p>
<dl class="simple">
<dt>no_time_detrend: Don’t deterend in time, useful fo low dm</dt><dd><p>where pulse&gt;%50 of the channel</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Dynamic Spectrum with values clipped</p>
</dd>
<dt>See:</dt><dd><p><a class="reference external" href="https://github.com/rohinijoshi06/mad-filter-gpu">https://github.com/rohinijoshi06/mad-filter-gpu</a></p>
<p>Kendrick Smith’s talks about CHIME FRB</p>
</dd>
<dt>Note:</dt><dd><p>This has better performance than spectral_mad, you should probably use this one.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.mad_time">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">mad_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gulp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_values</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.mad_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the spectral Kurtosis along the time axis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>gulp: the dynamic spectum to be analyzed</p>
</dd>
</dl>
<p>`   sigma on to cut kurtosis values</p>
<blockquote>
<div><p>frame: number of time samples to calculate the kurtosis</p>
<p>apply_mask: Apply the mask to the data, replacing bad values with zeros</p>
</div></blockquote>
<p>Returns:</p>
<blockquote>
<div><p>Mask based on bad iqr sections</p>
<p>optional: apply mask as replace with zeros</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.mad_time_cutter">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">mad_time_cutter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gulp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.mad_time_cutter" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Median Absolute Deviations along the time axis</p>
<dl>
<dt>Args:</dt><dd><p>frame: number of time samples to calculate the kurtosis</p>
<p>sigma: cutoff sigma</p>
</dd>
</dl>
<p>Returns:</p>
<blockquote>
<div><p>Dynamic Spectrum with values clipped</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.run_filter">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">run_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.run_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs filter on a file</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.sad_spectra">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">sad_spectra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gulp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">65</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.sad_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Savgol Absolute Deviations along the spectral axis</p>
<dl>
<dt>Args:</dt><dd><p>frame: number of time samples to calculate the SAD</p>
<p>sigma: cutoff sigma</p>
</dd>
</dl>
<p>Returns:</p>
<blockquote>
<div><p>Dynamic Spectrum with values clipped</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.sad_time">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">sad_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gulp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">65</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.sad_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Savgol Absolute Deviations along the time axis</p>
<dl>
<dt>Args:</dt><dd><p>frame: number of time samples to calculate the SAD</p>
<p>sigma: cutoff sigma</p>
</dd>
</dl>
<p>Returns:</p>
<blockquote>
<div><p>Dynamic Spectrum with values clipped</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.skew_calculate_values">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">skew_calculate_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters.skew_calculate_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Skew for blocks of length window.</p>
<dl>
<dt>Args:</dt><dd><p>yr_file: The Your object for a FITS/fil file to process</p>
<p>window: window length in number of time samples</p>
<dl class="simple">
<dt>time_median_kernel: Detrend in time by subtracting a smoothed running</dt><dd><p>median, smoothed bt time_median_kernel</p>
</dd>
</dl>
<p>bandpass_kernel: bandpass kernel to smooth bandpass</p>
</dd>
<dt>Returns:</dt><dd><p>Skew values for each block in the file</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.std_iqr_calculate_values">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">std_iqr_calculate_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_file</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass_kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">7</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.std_iqr_calculate_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the difference between Standard Deviation and Inter Quatile Range
(scaled to give STD) This is the difference between a robust measure
and non-robust measure of scale.
For Gaussian data then should agree, with outliers, this will differ.</p>
<dl>
<dt>Args:</dt><dd><p>yr_file: The Your object for a FITS/fil file to process</p>
<p>window: window length in number of time samples</p>
<dl class="simple">
<dt>time_median_kernel: Detrend in time by subtracting a smoothed running</dt><dd><p>median, smoothed bt time_median_kernel</p>
</dd>
</dl>
<p>bandpass_kernel: bandpass kernel to smooth bandpass</p>
</dd>
<dt>Returns:</dt><dd><p>Distances for each block</p>
</dd>
<dt>Notes:</dt><dd><p>Kevin’s idea</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.sum_threasthold_aprls">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">sum_threasthold_aprls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.sum_threasthold_aprls" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a mask to cover the RFI in a data set based on ArPLS-ST.</p>
<dl>
<dt>Args:</dt><dd><p>dynamic_spectra - Array containing the signal and RFI</p>
<p>eta_i - List of sensitivities</p>
</dd>
<dt>Returns:</dt><dd><p>2D mask where True = RFI</p>
</dd>
<dt>Note:</dt><dd><p>From <a class="reference external" href="http://zmtt.bao.ac.cn/GPPS/RFI/">http://zmtt.bao.ac.cn/GPPS/RFI/</a>
Cite: <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2021MNRAS.500.2969Z">https://ui.adsabs.harvard.edu/abs/2021MNRAS.500.2969Z</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.sum_threshold">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">sum_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(0.5,</span> <span class="pre">0.55,</span> <span class="pre">0.62,</span> <span class="pre">0.75,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chi_1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">35000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_standing_waves</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suppress_dilation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sm_kwargs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">di_kwargs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_pixels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters.sum_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a mask to cover the RFI in a data set.</p>
<dl>
<dt>Args:</dt><dd><p>dynamic_spectra - Array containing the signal and RFI</p>
<p>chi_1 - First threshold</p>
<p>eta_i - List of sensitivities</p>
<p>max_pixels - Controls the max iteration and chi_1</p>
</dd>
<dt>KWArgs:</dt><dd><p>normalize_standing_waves - Whether to normalize standing waves</p>
<p>suppress_dilation -  If true, mask dilation is suppressed</p>
<p>plotting - True if statistics plot should be displayed</p>
<p>sm_kwargs - Smoothing key words</p>
<p>di_kwargs - dilation key words</p>
</dd>
<dt>Returns:</dt><dd><p>mask - the mask covering the identified RFI</p>
</dd>
<dt>Note:</dt><dd><p>From
<a class="reference external" href="https://cosmo-gitlab.phys.ethz.ch/cosmo_public/seek/-/blob/master/seek/mitigation/sum_threshold.py">https://cosmo-gitlab.phys.ethz.ch/cosmo_public/seek/-/blob/master/seek/mitigation/sum_threshold.py</a>
Cite <a class="reference external" href="https://arxiv.org/abs/1607.07443">https://arxiv.org/abs/1607.07443</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.zero_dm">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">zero_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass:</span> <span class="pre">typing.Optional[numpy.ndarray]</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intermediate_dtype:</span> <span class="pre">type</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#jess.JESS_filters.FilterResult" title="jess.JESS_filters.FilterResult"><span class="pre">jess.JESS_filters.FilterResult</span></a></span></span><a class="headerlink" href="#jess.JESS_filters.zero_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask-safe zero-dm subtraction</p>
<dl>
<dt>args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: The data you want to zero-dm, expects times samples</dt><dd><p>on the vertical axis. Accepts numpy.ma.arrays.</p>
</dd>
<dt>bandpass - Use if a large file is broken up into pieces.</dt><dd><p>Be careful about how you use this with masks.</p>
</dd>
</dl>
<p>intermediate_dtype - The data type to do the calculations</p>
<p>return_same_dtype: return the same data type as given</p>
</dd>
<dt>returns:</dt><dd><p>dynamic spectra with a (more) uniform zero time series</p>
</dd>
<dt>note:</dt><dd><p>This should masked values. I am mainly conserned with bad data being spread out
ny the filter, and this ignores masked values when calculating time series
and bandpass</p>
</dd>
<dt>example:</dt><dd><p>yr = Your(“some.fil”)
dynamic_spectra = yr.get_data(744000, 2 ** 14)</p>
<p>mask = np.zeros(yr.your_header.nchans, dtype=bool)
mask[0:100] = True # mask the first hundred channels</p>
<dl class="simple">
<dt>dynamic_spectra = np.ma.array(dynamic_spectra,</dt><dd><p>mask=np.broadcast_to(dynamic_spectra.shape))</p>
</dd>
</dl>
<p>cleaned = zero_dm(dynamic_spectra)</p>
</dd>
<dt>from:</dt><dd><p>“An interference removal technique for radio pulsar searches” R.P Eatough 2009</p>
</dd>
<dt>see:</dt><dd><p><a class="reference external" href="https://github.com/SixByNine/sigproc/blob/28ba4f4539d41a8722c6ed194fa66e87bf4610fc/src/zerodm.c#L195">https://github.com/SixByNine/sigproc/blob/28ba4f4539d41a8722c6ed194fa66e87bf4610fc/src/zerodm.c#L195</a></p>
<p><a class="reference external" href="https://sourceforge.net/p/heimdall-astro/code/ci/master/tree/Pipeline/clean_filterbank_rfi.cu">https://sourceforge.net/p/heimdall-astro/code/ci/master/tree/Pipeline/clean_filterbank_rfi.cu</a></p>
<p><a class="reference external" href="https://github.com/scottransom/presto/blob/de2cf58262190d35fb37dbebf8308a6e29d72adf/src/zerodm.c">https://github.com/scottransom/presto/blob/de2cf58262190d35fb37dbebf8308a6e29d72adf/src/zerodm.c</a></p>
<p><a class="reference external" href="https://github.com/thepetabyteproject/your/blob/1f4b39326835e6bb87e0003318b433dc1455a137/your/writer.py#L232">https://github.com/thepetabyteproject/your/blob/1f4b39326835e6bb87e0003318b433dc1455a137/your/writer.py#L232</a></p>
<p><a class="reference external" href="https://sigpyproc3.readthedocs.io/en/latest/_modules/sigpyproc/Filterbank.html#Filterbank.removeZeroDM">https://sigpyproc3.readthedocs.io/en/latest/_modules/sigpyproc/Filterbank.html#Filterbank.removeZeroDM</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters.zero_dm_fft">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters.</span></span><span class="sig-name descname"><span class="pre">zero_dm_fft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes_to_zero</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#jess.JESS_filters.FilterResult" title="jess.JESS_filters.FilterResult"><span class="pre">jess.JESS_filters.FilterResult</span></a></span></span><a class="headerlink" href="#jess.JESS_filters.zero_dm_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>This removes low frequency components from each spectra. This extends 0-DM
subtraction. 0-DM subtraction as described in Eatough 2009, involves subtraction
of the mean of each spectra from each spectra, makeing the zero-DM time series
contant. This is effective in removing broadband RFI that has no structure.</p>
<p>This is very effective for moderate bandwidths and low dynamic ranges.
As bandwidths increase, we can see zero-DM RFI that only extends through
part of the band. Increases in dynamic range allow for zero-DM RFI to have
spectral structure, either intrinsically or the result of the receiving chain.</p>
<p>This attempts to corret for these problems with the subtraction method.
This removes the zero Fourier term (the total power), equivalent to the
subtraction method. It also can remove higher order terms, removing slowing
signals across the band.</p>
<p>You need to be careful about how many terms you remove. We will start to
to remove more components of the pulse. When this happens is determined
by the fraction of the band that contains the pulse. The larger the pulse,
the lower the Fourier components.</p>
<dl>
<dt>args:</dt><dd><dl class="simple">
<dt>dynamic_spectra - The dynamic spectra you want to clean. Time axis</dt><dd><p>must be verticals</p>
</dd>
<dt>bandpass - Bandpass to add. We subtract off the DC component, we</dt><dd><p>must add it back to safely write the data as unsigned ints
if no bandpass is given, this will use the bandpass from the
dynamic spectra given, this can cause jumps if you are processing
multiple chunks.</p>
</dd>
</dl>
<p>modes_to_zero - The number of modes to filter, starting at the lowest mode</p>
<p>return_same_dtype: return the same data type as given</p>
</dd>
<dt>returns:</dt><dd><p>dynamic spectra with low frequency modes filtered, same data type as given</p>
</dd>
<dt>notes:</dt><dd><p>See jess.filters.zero_dm Docstring for other implementations
of subtraction 0-dm filters.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-jess.JESS_filters_cupy">
<span id="jess-jess-filters-cupy-module"></span><h2>jess.JESS_filters_cupy module<a class="headerlink" href="#module-jess.JESS_filters_cupy" title="Permalink to this headline">¶</a></h2>
<p>This contains cupy versions of some of JESS_filters</p>
<dl class="py class">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.FilterMaskResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_cupy.</span></span><span class="sig-name descname"><span class="pre">FilterMaskResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percent_masked</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters_cupy.FilterMaskResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<p>dynamic_spectra - Dynamic Spectra with RFI filtered
mask - Boolean mask
percent_masked - The percent masked</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.FilterMaskResult.dynamic_spectra">
<span class="sig-name descname"><span class="pre">dynamic_spectra</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#jess.JESS_filters_cupy.FilterMaskResult.dynamic_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.FilterMaskResult.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">cupy._core.core.ndarray</span></em><a class="headerlink" href="#jess.JESS_filters_cupy.FilterMaskResult.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.FilterMaskResult.percent_masked">
<span class="sig-name descname"><span class="pre">percent_masked</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.float64</span></em><a class="headerlink" href="#jess.JESS_filters_cupy.FilterMaskResult.percent_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.FilterResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_cupy.</span></span><span class="sig-name descname"><span class="pre">FilterResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percent_masked</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters_cupy.FilterResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<p>dynamic_spectra - Dynamic Spectra with RFI filtered
percent_masked - The percent masked</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.FilterResult.dynamic_spectra">
<span class="sig-name descname"><span class="pre">dynamic_spectra</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">cupy._core.core.ndarray</span></em><a class="headerlink" href="#jess.JESS_filters_cupy.FilterResult.dynamic_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.FilterResult.percent_masked">
<span class="sig-name descname"><span class="pre">percent_masked</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.float64</span></em><a class="headerlink" href="#jess.JESS_filters_cupy.FilterResult.percent_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.fft_mad">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_cupy.</span></span><span class="sig-name descname"><span class="pre">fft_mad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitter:</span> <span class="pre">typing.Callable</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">poly_fitter&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bad_chans:</span> <span class="pre">typing.Optional[numpy.ndarray]</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters_cupy.fft_mad" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the real FFT of the dynamic spectra along the time axis
(a FFT for each channel). Then take the absolute value, this
gives the magnitude of the power &#64; each frequency.</p>
<p>Then run the MAD filter along the freqency axis, this looks for
outliers in the in the spectra. Narrow band RFI will only be
in a few channels, add will be flagged.</p>
<p>This mask is then used to flag the complex FFT by setting the
flagged points to zero. The first row is excluded because this
is the powers for each channel. This could be zero, but it has
so effect, and keeping it at its current value keeps the
bandpass smooth.</p>
<p>The masked FFT is then inverse real fft back. Data is clip to
min/max for the given input data type and returned as that
data type.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: spectra block with time on the vertical axis,</dt><dd><p>and freq on the horizontal</p>
</dd>
</dl>
<p>chans_per_subband: number of frequency samples to calculate MAD</p>
<p>time_median_size: the length of the median filter to run in time</p>
<p>sigma: cutoff sigma</p>
<p>chans_per_fit: polynomial/spline knots per channel to fit the bandpass</p>
<p>fitter: which fitter to use, see jess.fitters for options</p>
<dl class="simple">
<dt>bad_chans: list of bad channels - these have all information</dt><dd><p>removed except for the power</p>
</dd>
</dl>
<p>return_same_dtype: return the same data type as given</p>
<p>return_mask: return the bool mask of flagged frequencies</p>
</dd>
<dt>Returns:</dt><dd><p>Dynamic Spectrum with narrow band perodic RFI removed.</p>
<p>(optional) bool mask of frequencies where bad=True</p>
</dd>
</dl>
<p>See:</p>
<blockquote>
<div><p>For MAD
<a class="reference external" href="https://github.com/rohinijoshi06/mad-filter-gpu">https://github.com/rohinijoshi06/mad-filter-gpu</a></p>
<p>For FFT cleaning
<a class="reference external" href="https://arxiv.org/abs/2012.11630">https://arxiv.org/abs/2012.11630</a> &amp; <a class="reference external" href="https://github.com/ymaan4/RFIClean">https://github.com/ymaan4/RFIClean</a></p>
</div></blockquote>
<dl class="simple">
<dt>Note:</dt><dd><p>This provides a 1% difference in masks from the CPU version. This results in
a 0.1% higher standard deviation of the zero dm time series.
This seems negligible, this version provides 2x speed up on a GTX 1030 over
24 threads of X5675.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.filter_weights">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_cupy.</span></span><span class="sig-name descname"><span class="pre">filter_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric:</span> <span class="pre">typing.Callable</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">median&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass_smooth_length:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_sigma:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.6666666666666666</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_sigma:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">30</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters_cupy.filter_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes weights based on low values of some meteric.
This is designed to ignore bandpass filters or tapers
at the end of the bandpass.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra - 2D dynamic spectra with time on the</dt><dd><p>vertical axis</p>
</dd>
</dl>
<p>metric - The statistic to sample.</p>
<dl class="simple">
<dt>bandpass_smooth_length - length of the median filter to</dt><dd><p>smooth the bandpass</p>
</dd>
</dl>
<p>sigma_cut - Cut values below (standard deviation)*(sigma cut)</p>
<dl class="simple">
<dt>smooth_sigma - Gaussian filter smoothing sigma. If =0, return</dt><dd><p>the mask where True=good channels</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Bandpass weights for sections of spectra with low values.
0 where the value is below the threshold and 1 elsewhere,
with a Gaussian taper.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.iterative_mad">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_cupy.</span></span><span class="sig-name descname"><span class="pre">iterative_mad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">filter_weight_args</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#jess.JESS_filters_cupy.FilterResult" title="jess.JESS_filters_cupy.FilterResult"><span class="pre">jess.JESS_filters_cupy.FilterResult</span></a></span></span><a class="headerlink" href="#jess.JESS_filters_cupy.iterative_mad" title="Permalink to this definition">¶</a></dt>
<dd><p>Interatively clean a chunk of dynamic spectra.
If filter_weight_args is not <cite>None</cite>, masks channels that
are unlikely to have signal. MAD and MAD FFT are run.
Then the channels are decimated by <cite>factor</cite> and MAD is run
again, decreasing <cite>chans_per_subband</cite> by <cite>factor</cite>. This
is repeated until <cite>factor</cite> channels, when the mean is taken</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: a dynamic spectra with time on the vertical axis,</dt><dd><p>and freq on the horizontal</p>
</dd>
</dl>
<p>factor - Factor to reduce each iteration</p>
<p>chans_per_subband: Number of channels to calculate the MAD</p>
<p>sigma: sigma which to reject outliers</p>
<p>flatten_to: the median of the output data</p>
<p>time_median_size: the length of the median filter to run in time</p>
<dl class="simple">
<dt>filter_weight_args: Passed to <cite>filter_weights</cite>, if <cite>None</cite> no</dt><dd><p>filter of channels.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Cleaned Time Series</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.mad_spectra">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_cupy.</span></span><span class="sig-name descname"><span class="pre">mad_spectra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters_cupy.mad_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Median Absolute Deviations along the spectral axis
(i.e. for each time sample across all channels)</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: spectra with time on the vertical axis,</dt><dd><p>and freq on the horizontal</p>
</dd>
</dl>
<p>frame: number of frequency samples to calculate the MAD</p>
<p>sigma: cutoff sigma</p>
<p>poly_order: polynomial order to fit for the bandpass</p>
<p>return_same_dtype: return the same data type as given</p>
</dd>
<dt>Returns:</dt><dd><p>Dynamic Spectrum with values clipped</p>
</dd>
<dt>Notes:</dt><dd><p>This version differs from the cpu version.
This uses nans, while cpu version uses np.ma mask,
excision performance is about the same. See the cpu docstring for
references.</p>
<p>mask = True, for good values</p>
<p>You should use spectral_mad_flat (which has better RFI removal) unless
you really need to preserve the bandpass.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.mad_spectra_flat">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_cupy.</span></span><span class="sig-name descname"><span class="pre">mad_spectra_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_time_detrend</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters_cupy.mad_spectra_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Median Absolute Deviations along the spectral axis
(i.e. for each time sample across all channels). This flattens the
data by subtracting the rolling median of median of time and frequencies.
It then calculates the Median Absolute Deviation for every frame channels.
Outliers are removed based on the assumption of Gaussian data. The dynamic
spectra is then detrended again, masking the outliers. This process is then
repeated again. The data is returned centerned around flatten_to with removed
points set as flatten_to.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: a dynamic spectra with time on the vertical axis,</dt><dd><p>and freq on the horizontal</p>
</dd>
</dl>
<p>chans_per_subband: number of channels to calculate the MAD</p>
<p>sigma: sigma which to reject outliers</p>
<p>flatten_to: the median of the output data</p>
<p>time_median_size: the length of the median filter to run in time</p>
<p>return_mask: return the mask where True=masked_values</p>
<p>return_same_dtype: return the same data type as given</p>
<dl class="simple">
<dt>no_time_detrend: Don’t deterend in time, useful fo low dm</dt><dd><p>where pulse&gt;%50 of the channel</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Dynamic Spectrum with values clipped</p>
</dd>
<dt>See:</dt><dd><p><a class="reference external" href="https://github.com/rohinijoshi06/mad-filter-gpu">https://github.com/rohinijoshi06/mad-filter-gpu</a></p>
<p>Kendrick Smith’s talks about CHIME FRB</p>
</dd>
<dt>Note:</dt><dd><p>This has better performance than spectral_mad, you should probably use this one.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.zero_dm">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_cupy.</span></span><span class="sig-name descname"><span class="pre">zero_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass:</span> <span class="pre">typing.Optional[cupy._core.core.ndarray]</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intermediate_dtype:</span> <span class="pre">type</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#jess.JESS_filters_cupy.FilterResult" title="jess.JESS_filters_cupy.FilterResult"><span class="pre">jess.JESS_filters_cupy.FilterResult</span></a></span></span><a class="headerlink" href="#jess.JESS_filters_cupy.zero_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask-safe zero-dm subtraction</p>
<dl>
<dt>args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: The data you want to zero-dm, expects times samples</dt><dd><p>on the vertical axis. Accepts numpy.ma.arrays.</p>
</dd>
<dt>bandpass - Use if a large file is broken up into pieces.</dt><dd><p>Be careful about how you use this with masks.</p>
</dd>
</dl>
<p>intermediate_dtype - The data type to do the calculations</p>
<p>return_same_dtype: return the same data type as given</p>
</dd>
<dt>returns:</dt><dd><p>dynamic spectra with a (more) uniform zero time series</p>
</dd>
<dt>note:</dt><dd><p>This should masked values. I am mainly conserned with bad data being spread out
ny the filter, and this ignores masked values when calculating time series
and bandpass</p>
<p>The CPU version of this uses np.ma, this isn’t available form cupy, so I
don’t use it here. This doesn’t seem when writing this.</p>
</dd>
<dt>example:</dt><dd><p>yr = Your(“some.fil”)
dynamic_spectra = yr.get_data(744000, 2 ** 14)</p>
<p>mask = np.zeros(yr.your_header.nchans, dtype=bool)
mask[0:100] = True # mask the first hundred channels</p>
<dl class="simple">
<dt>dynamic_spectra = np.ma.array(dynamic_spectra,</dt><dd><p>mask=np.broadcast_to(dynamic_spectra.shape))</p>
</dd>
</dl>
<p>cleaned = zero_dm(dynamic_spectra)</p>
</dd>
<dt>from:</dt><dd><p>“An interference removal technique for radio pulsar searches” R.P Eatough 2009</p>
</dd>
<dt>see:</dt><dd><p><a class="reference external" href="https://github.com/SixByNine/sigproc/blob/28ba4f4539d41a8722c6ed194fa66e87bf4610fc/src/zerodm.c#L195">https://github.com/SixByNine/sigproc/blob/28ba4f4539d41a8722c6ed194fa66e87bf4610fc/src/zerodm.c#L195</a></p>
<p><a class="reference external" href="https://sourceforge.net/p/heimdall-astro/code/ci/master/tree/Pipeline/clean_filterbank_rfi.cu">https://sourceforge.net/p/heimdall-astro/code/ci/master/tree/Pipeline/clean_filterbank_rfi.cu</a></p>
<p><a class="reference external" href="https://github.com/scottransom/presto/blob/de2cf58262190d35fb37dbebf8308a6e29d72adf/src/zerodm.c">https://github.com/scottransom/presto/blob/de2cf58262190d35fb37dbebf8308a6e29d72adf/src/zerodm.c</a></p>
<p><a class="reference external" href="https://github.com/thepetabyteproject/your/blob/1f4b39326835e6bb87e0003318b433dc1455a137/your/writer.py#L232">https://github.com/thepetabyteproject/your/blob/1f4b39326835e6bb87e0003318b433dc1455a137/your/writer.py#L232</a></p>
<p><a class="reference external" href="https://sigpyproc3.readthedocs.io/en/latest/_modules/sigpyproc/Filterbank.html#Filterbank.removeZeroDM">https://sigpyproc3.readthedocs.io/en/latest/_modules/sigpyproc/Filterbank.html#Filterbank.removeZeroDM</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_cupy.zero_dm_fft">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_cupy.</span></span><span class="sig-name descname"><span class="pre">zero_dm_fft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">cupy._core.core.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes_to_zero</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#jess.JESS_filters_cupy.FilterResult" title="jess.JESS_filters_cupy.FilterResult"><span class="pre">jess.JESS_filters_cupy.FilterResult</span></a></span></span><a class="headerlink" href="#jess.JESS_filters_cupy.zero_dm_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>This removes low frequency components from each spectra. This extends 0-DM
subtraction. 0-DM subtraction as described in Eatough 2009, involves subtraction
of the mean of each spectra from each spectra, makeing the zero-DM time series
contant. This is effective in removing broadband RFI that has no structure.</p>
<p>This is very effective for moderate bandwidths and low dynamic ranges.
As bandwidths increase, we can see zero-DM RFI that only extends through
part of the band. Increases in dynamic range allow for zero-DM RFI to have
spectral structure, either intrinsically or the result of the receiving chain.</p>
<p>This attempts to corret for these problems with the subtraction method.
This removes the zero Fourier term (the total power), equivalent to the
subtraction method. It also can remove higher order terms, removing slowing
signals across the band.</p>
<p>You need to be careful about how many terms you remove. We will start to
to remove more components of the pulse. When this happens is determined
by the fraction of the band that contains the pulse. The larger the pulse,
the lower the Fourier components.</p>
<dl>
<dt>args:</dt><dd><dl class="simple">
<dt>dynamic_spectra - The dynamic spectra you want to clean. Time axis</dt><dd><p>must be vertical</p>
</dd>
<dt>bandpass - Bandpass to add. We subtract off the DC component, we</dt><dd><p>must add it back to safely write the data as unsigned ints
if no bandpass is given, this will use the bandpass from the
dynamic spectra given, this can cause jumps if you are processing
multiple chunks.</p>
</dd>
</dl>
<p>modes_to_zero - The number of modes to filter.</p>
<p>return_same_dtype: return the same data type as given</p>
</dd>
<dt>returns:</dt><dd><p>dynamic spectra with low frequency modes filtered, same data type as given</p>
</dd>
<dt>notes:</dt><dd><p>See jess.filters.zero_dm Docstring for other implementations
of subtraction 0-dm filters.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-jess.JESS_filters_generic">
<span id="jess-jess-filters-generic-module"></span><h2>jess.JESS_filters_generic module<a class="headerlink" href="#module-jess.JESS_filters_generic" title="Permalink to this headline">¶</a></h2>
<p>Generic (cupy/numpy) filters.</p>
<p>This is a test of writing generic backend filters.
It relies on the user giving the correct ndarray.</p>
<p>If this is successful, we should merge JESS_fiters and
JESS_fiters_cupy into here.</p>
<dl class="py class">
<dt class="sig sig-object py" id="jess.JESS_filters_generic.FilterMaskResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_generic.</span></span><span class="sig-name descname"><span class="pre">FilterMaskResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percent_masked</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.JESS_filters_generic.FilterMaskResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<p>dynamic_spectra - Dynamic Spectra with RFI filtered
mask - Boolean mask
percent_masked - The percent masked</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters_generic.FilterMaskResult.dynamic_spectra">
<span class="sig-name descname"><span class="pre">dynamic_spectra</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">cupy._core.core.ndarray</span></em><a class="headerlink" href="#jess.JESS_filters_generic.FilterMaskResult.dynamic_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters_generic.FilterMaskResult.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">cupy._core.core.ndarray</span></em><a class="headerlink" href="#jess.JESS_filters_generic.FilterMaskResult.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="jess.JESS_filters_generic.FilterMaskResult.percent_masked">
<span class="sig-name descname"><span class="pre">percent_masked</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.float64</span></em><a class="headerlink" href="#jess.JESS_filters_generic.FilterMaskResult.percent_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_generic.jarque_bera">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_generic.</span></span><span class="sig-name descname"><span class="pre">jarque_bera</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples_per_block:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">4096</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend:</span> <span class="pre">typing.Optional[typing.Tuple]</span> <span class="pre">=</span> <span class="pre">(&lt;function</span> <span class="pre">median_fitter&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">40)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winsorize_args:</span> <span class="pre">typing.Optional[typing.Tuple]</span> <span class="pre">=</span> <span class="pre">(5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">40)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_policy:</span> <span class="pre">typing.Optional[str]</span> <span class="pre">=</span> <span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters_generic.jarque_bera" title="Permalink to this definition">¶</a></dt>
<dd><p>Jarque-Bera Gaussianity test, this uses a combination of Kurtosis and Skew.
We calculate Jarque-Bera along the time axis in blocks of <cite>samples_per_block</cite>.
This is balanced if the number of samples is not evenly divisible.
The Jarque-Bera statstic is Chi-Squared distributed with two degrees of freedom.
This makes our Gaussian outlier flagging remove more data than expected.
To combate this we take the squareroot of the Jarque Statistic, this makes the
distrabution more Gaussian and the flagging work better.</p>
<dl>
<dt>Args:</dt><dd><p>dynamic_spectra - Section spectra time on the vertical axis</p>
<p>samples_per_block - Time samples for each channel block</p>
<dl class="simple">
<dt>detrend - Detrend Kurtosis and Skew values (fitter, chans_per_fit).</dt><dd><p>If <cite>None</cite>, no detrend</p>
</dd>
<dt>winsorize_args - Winsorize the second moments. See scipy_cupy.stats.winsorize</dt><dd><p>If <cite>None</cite>, no winorization.</p>
</dd>
</dl>
<p>nan_policy - How to propagate nans. If None, does not check for nans.</p>
</dd>
<dt>Returns:</dt><dd><p>bool Mask with True=bad data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_generic.kurtosis_and_skew">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_generic.</span></span><span class="sig-name descname"><span class="pre">kurtosis_and_skew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples_per_block:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">4096</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend:</span> <span class="pre">typing.Optional[typing.Tuple]</span> <span class="pre">=</span> <span class="pre">(&lt;function</span> <span class="pre">median_fitter&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">40)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winsorize_args:</span> <span class="pre">typing.Optional[typing.Tuple]</span> <span class="pre">=</span> <span class="pre">(5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">40)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_policy:</span> <span class="pre">typing.Optional[str]</span> <span class="pre">=</span> <span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters_generic.kurtosis_and_skew" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussainity test using Kurtosis and Skew. We calculate Kurtosis and skew along
the time axis in blocks of <cite>samples_per_block</cite>. This is balanced if the number
of samples is not evenly divisible. We then use the central limit theorem to
flag outlying samples in Kurtosis and Skew individually. These masks are then
added together.</p>
<dl>
<dt>Args:</dt><dd><p>dynamic_spectra - Section spectra time on the vertical axis</p>
<p>samples_per_block - Time samples for each channel block</p>
<dl class="simple">
<dt>detrend - Detrend Kurtosis and Skew values (fitter, chans_per_fit).</dt><dd><p>If <cite>None</cite>, no detrend</p>
</dd>
<dt>winsorize_args - Winsorize the second moments. See scipy_cupy.stats.winsorize</dt><dd><p>If <cite>None</cite>, no winorization.</p>
</dd>
</dl>
<p>nan_policy - How to propagate nans. If None, does not check for nans.</p>
</dd>
<dt>Returns:</dt><dd><p>bool Mask with True=bad data</p>
</dd>
<dt>Notes:</dt><dd><p>Flagging based on
<a class="reference external" href="https://www.worldscientific.com/doi/10.1142/S225117171940004X">https://www.worldscientific.com/doi/10.1142/S225117171940004X</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.JESS_filters_generic.mad_spectra_flat">
<span class="sig-prename descclassname"><span class="pre">jess.JESS_filters_generic.</span></span><span class="sig-name descname"><span class="pre">mad_spectra_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_median_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_chans</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_time_detrend</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.JESS_filters_generic.mad_spectra_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Median Absolute Deviations along the spectral axis
(i.e. for each time sample across all channels). This flattens the
data by subtracting the rolling median of median of time and frequencies.
It then calculates the Median Absolute Deviation for every frame channels.
Outliers are removed based on the assumption of Gaussian data. The dynamic
spectra is then detrended again, masking the outliers. This process is then
repeated again. The data is returned centerned around flatten_to with removed
points set as flatten_to.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dynamic_spectra: a dynamic spectra with time on the vertical axis,</dt><dd><p>and freq on the horizontal</p>
</dd>
</dl>
<p>chans_per_subband: number of channels to calculate the MAD</p>
<p>sigma: sigma which to reject outliers</p>
<p>flatten_to: the median of the output data</p>
<p>time_median_size: the length of the median filter to run in time</p>
<dl class="simple">
<dt>mask_chan - Mask bad channels based on differing mean and median</dt><dd><p>seems to be a good test for non-linearity</p>
</dd>
</dl>
<p>return_same_dtype: return the same data type as given</p>
<dl class="simple">
<dt>no_time_detrend: Don’t deterend in time, useful fo low dm</dt><dd><p>where pulse&gt;%50 of the channel</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Dynamic Spectrum with values clipped</p>
</dd>
<dt>See:</dt><dd><p><a class="reference external" href="https://github.com/rohinijoshi06/mad-filter-gpu">https://github.com/rohinijoshi06/mad-filter-gpu</a></p>
<p>Kendrick Smith’s talks about CHIME FRB</p>
</dd>
<dt>Note:</dt><dd><p>This has better performance than spectral_mad, you should probably use this one.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-jess.calculators">
<span id="jess-calculators-module"></span><h2>jess.calculators module<a class="headerlink" href="#module-jess.calculators" title="Permalink to this headline">¶</a></h2>
<p>The repository for all calculators</p>
<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.accumulate">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">accumulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.calculators.accumulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the data along an axis by taking the mean of a ‘factor’ of rows along
the axis</p>
<dl>
<dt>args:</dt><dd><p>data_array: array of data to be reduces</p>
<p>factor: the factor to reduce the dimension by</p>
<p>axis: axis to operate on</p>
</dd>
<dt>returns:</dt><dd><p>array with axis reduced by factor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.autocorrelate">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">autocorrelate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.calculators.autocorrelate" title="Permalink to this definition">¶</a></dt>
<dd><p>Auto correlation along an axis</p>
<dl>
<dt>Args:</dt><dd><p>data: data to find the autocorrelaton</p>
<p>axis: axis to find the autocorrlation, -1, 0, 1 available</p>
</dd>
<dt>Returns:</dt><dd><p>Auto correlation along an axis</p>
</dd>
<dt>Notes:</dt><dd><p>Uses mean to flatten, if complex structure, should do a better
detrend</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.balance_chans_per_subband">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">balance_chans_per_subband</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_chans</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_subband</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#jess.calculators.balance_chans_per_subband" title="Permalink to this definition">¶</a></dt>
<dd><p>Balance chan_per_subband when they are not evenly dividable</p>
<dl>
<dt>Args:</dt><dd><p>num_chans: total number of channels</p>
<p>num_subbands: number of subbands</p>
</dd>
<dt>Return:</dt><dd><p>[number of sections, array with start and stops of each of the subband]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.closest_larger_factor">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">closest_larger_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#jess.calculators.closest_larger_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the closest factor that is larger than a number.</p>
<dl>
<dt>args:</dt><dd><p>num: The number of to find the largest factor</p>
<p>factor: Factor to divide by</p>
</dd>
<dt>returns:</dt><dd><p>Closest factor of <cite>factor</cite> larger than <cite>num</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.decimate">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">decimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_factor:</span> <span class="pre">typing.Optional[int]</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_factor:</span> <span class="pre">typing.Optional[int]</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend:</span> <span class="pre">typing.Callable</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">decimate&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.calculators.decimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes decimates along either/both time and frequency axes.
Flattens data along frequency before freqency decimation.
Fattens again in frequency before returning.</p>
<dl>
<dt>args:</dt><dd><p>dynamic_spectra: dynamic spectra with time on the ventricle axis</p>
<p>time_factor: factor to reduce time sampling by</p>
<p>freq_factor: factor to reduce freqency channels</p>
<dl class="simple">
<dt>backend: backend to use to reduce the dimension, default is</dt><dd><p>signal.decimate, consider using jess.calculator.mean</p>
</dd>
</dl>
</dd>
<dt>returns:</dt><dd><p>Flattened in frequency dynamic spectra, reduced in time and/or freqency</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.divide_range">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">divide_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_sections</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.calculators.divide_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide range as evenly as possible.</p>
<dl>
<dt>Args:</dt><dd><p>length: length of array</p>
<p>num_sections: number of sections to divide array</p>
</dd>
<dt>Return:</dt><dd><p>array with start and stops of each of the subsections</p>
</dd>
<dt>Note:</dt><dd><p>Adapted from numpy.lib.shape_base.array_split
and subject to the numpy license</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.flattner_median">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">flattner_median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_to:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_time_series:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intermediate_dtype:</span> <span class="pre">type</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#jess.calculators.flattner_median" title="Permalink to this definition">¶</a></dt>
<dd><p>This flattens the dynamic spectra by subtracting the medians of the time series
and then the medians of the of bandpass. Then add flatten_to to all the pixels
so that the data can be keep as the same data type.</p>
<dl>
<dt>args:</dt><dd><p>dynamic_spectra: The dynamic spectra you want to flatten</p>
<p>flatten_to: The number to set as the baseline</p>
<dl class="simple">
<dt>kernel_size: The size of the median filter to run over the medians</dt><dd><p>0,1 =&gt; nothing is applied</p>
</dd>
</dl>
<p>intermediate_dtype: the data type of the intermediate calculation</p>
<p>return_same_dtype: return the same data type as dynamic_spectra</p>
<dl class="simple">
<dt>return_time_series: return the time series difference from flatten_to</dt><dd><p>median_time_series - flatten_to</p>
</dd>
</dl>
</dd>
<dt>returns:</dt><dd><p>Dynamic spectra flattened in frequency and time
(optional) time series median</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.flattner_mix">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">flattner_mix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_to:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_time_series:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intermediate_dtype:</span> <span class="pre">type</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#jess.calculators.flattner_mix" title="Permalink to this definition">¶</a></dt>
<dd><p>This flattens the dynamic spectra by subtracting the medians of the time series
and then the medians of the of bandpass. Then add flatten_to to all the pixels
so that the data can be keep as the same data type.</p>
<p>This uses medians subtraction on the time series. This is less agressive and
leaved the mean subtraction for the zero-dm.</p>
<p>Mean subtraction across the spectrum allows for smoother transition between blocks.</p>
<dl>
<dt>args:</dt><dd><p>dynamic_spectra: The dynamic spectra you want to flatten</p>
<dl class="simple">
<dt>flatten_to: The number to set as the baseline</dt><dd><p>0,1 =&gt; nothing is applied</p>
</dd>
</dl>
<p>kernel_size: The size of the median filter to run over the medians</p>
<dl class="simple">
<dt>return_same_dtype: return the same data type as given, else it will</dt><dd><p>at least np.int64</p>
</dd>
<dt>return_time_series: return the time series median differences from flatten_to</dt><dd><p>median_time_series - flatten_to</p>
</dd>
</dl>
</dd>
<dt>returns:</dt><dd><p>Dynamic spectra flattened in frequency and time
(optional) time series medians</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.guassian_noise_adder">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">guassian_noise_adder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">standard_deviations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#jess.calculators.guassian_noise_adder" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Gaussian noise from multiple channels to estimate the time series</p>
<dl>
<dt>Args:</dt><dd><p>standard_deviation: Standard Deviations along the bandpass</p>
</dd>
<dt>Returns:</dt><dd><p>time series standard deviation</p>
</dd>
<dt>Notes:</dt><dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables#Independent_random_variables">https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables#Independent_random_variables</a></p>
<p>Variances add at the sum of squares, we are interested in Standard deviation,
so talk the square root.</p>
<p>We are taking the mean, do divide by the number of channels
(=number of standard deviations)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.highpass_window">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">highpass_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">window_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.calculators.highpass_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the coefficients to multiply the Fourier components
to make a highpass filter.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>window_length: the length of the half window</p>
</dd>
<dt>Returns:</dt><dd><p>Half of an inverted blackman window, will bw window_length long</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.mean">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'median'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.calculators.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the data along an axis by taking the mean of a ‘factor’ of rows along
the axis</p>
<dl>
<dt>args:</dt><dd><p>data_array: array of data to be reduces</p>
<p>factor: the factor to reduce the dimension by</p>
<p>axis: axis to operate on</p>
<dl class="simple">
<dt>pad: method to pad if axis is not divisible. If None</dt><dd><p>will not pad</p>
</dd>
</dl>
</dd>
<dt>returns:</dt><dd><p>array with axis reduced by factor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.median_abs_deviation_med">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">median_abs_deviation_med</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center:</span> <span class="pre">object</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">median&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_policy:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'propagate'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.calculators.median_abs_deviation_med" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median absolute deviation of the data along the given axis.
The median absolute deviation (MAD, <a href="#id4"><span class="problematic" id="id1">[1]_</span></a>) computes the median over the
absolute deviations from the median. It is a measure of dispersion
similar to the standard deviation but more robust to outliers <a class="footnote-reference brackets" href="#id3" id="id2">2</a>.
The MAD of an empty array is <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>.
.. versionadded:: 1.5.0
Parameters
———-
x : array_like</p>
<blockquote>
<div><p>Input array or object that can be converted to an array.</p>
</div></blockquote>
<dl class="simple">
<dt>axis<span class="classifier">int or None, optional</span></dt><dd><p>Axis along which the range is computed. Default is 0. If None, compute
the MAD over the entire array.</p>
</dd>
<dt>center<span class="classifier">callable, optional</span></dt><dd><p>A function that will return the central value. The default is to use
np.median. Any user defined function used will need to have the
function signature <code class="docutils literal notranslate"><span class="pre">func(arr,</span> <span class="pre">axis)</span></code>.</p>
</dd>
<dt>scale<span class="classifier">scalar or str, optional</span></dt><dd><p>The numerical value of scale will be divided out of the final
result. The default is 1.0. The string “normal” is also accepted,
and results in <cite>scale</cite> being the inverse of the standard normal
quantile function at 0.75, which is approximately 0.67449.
Array-like scale is also allowed, as long as it broadcasts correctly
to the output such that <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">/</span> <span class="pre">scale</span></code> is a valid operation. The
output dimensions depend on the input array, <cite>x</cite>, and the <cite>axis</cite>
argument.</p>
</dd>
<dt>nan_policy<span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional</span></dt><dd><p>Defines how to handle when input contains nan.
The following options are available (default is ‘propagate’):
* ‘propagate’: returns nan
* ‘raise’: throws an error
* ‘omit’: performs the calculations ignoring nan values</p>
</dd>
</dl>
<dl class="simple">
<dt>mad<span class="classifier">scalar or ndarray</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">axis=None</span></code>, a scalar is returned. If the input contains
integers or floats of smaller precision than <code class="docutils literal notranslate"><span class="pre">np.float64</span></code>, then the
output data-type is <code class="docutils literal notranslate"><span class="pre">np.float64</span></code>. Otherwise, the output data-type is
the same as that of the input.</p>
</dd>
</dl>
<p>center : The centers of each array
See Also
——–
numpy.std, numpy.var, numpy.median, scipy.stats.iqr, scipy.stats.tmean,
scipy.stats.tstd, scipy.stats.tvar
Notes
—–
Modifed from scipy.stats.median_abs_devation</p>
<p>The <cite>center</cite> argument only affects the calculation of the central value
around which the MAD is calculated. That is, passing in <code class="docutils literal notranslate"><span class="pre">center=np.mean</span></code>
will calculate the MAD around the mean - it will not calculate the <em>mean</em>
absolute deviation.
The input array may contain <cite>inf</cite>, but if <cite>center</cite> returns <cite>inf</cite>, the
corresponding MAD for that data will be <cite>nan</cite>.
References
———-
.. [1] “Median absolute deviation”,</p>
<blockquote>
<div><p><a class="reference external" href="https://en.wikipedia.org/wiki/Median_absolute_deviation">https://en.wikipedia.org/wiki/Median_absolute_deviation</a></p>
</div></blockquote>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>“Robust measures of scale”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Robust_measures_of_scale">https://en.wikipedia.org/wiki/Robust_measures_of_scale</a></p>
</dd>
</dl>
<p>When comparing the behavior of <cite>median_abs_deviation</cite> with <code class="docutils literal notranslate"><span class="pre">np.std</span></code>,
the latter is affected when we change a single value of an array to have an
outlier value while the MAD hardly changes:
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = stats.norm.rvs(size=100, scale=1, random_state=123456)
&gt;&gt;&gt; x.std()
0.9973906394005013
&gt;&gt;&gt; stats.median_abs_deviation(x)
0.82832610097857
&gt;&gt;&gt; x[0] = 345.6
&gt;&gt;&gt; x.std()
34.42304872314415
&gt;&gt;&gt; stats.median_abs_deviation(x)
0.8323442311590675
Axis handling example:
&gt;&gt;&gt; x = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; x
array([[10,  7,  4],</p>
<blockquote>
<div><p>[ 3,  2,  1]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">median_abs_deviation</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([3.5, 2.5, 1.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">median_abs_deviation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="go">Scale normal example:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">123456</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">median_abs_deviation</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1.3487398527041636</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">median_abs_deviation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">)</span>
<span class="go">1.9996446978061115</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.noise_calculator">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">noise_calculator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yr_obj</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">your.your.Your</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">len_block</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">17</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#jess.calculators.noise_calculator" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the ideal noise of a file</p>
<ol class="arabic simple">
<li><p>Get num_samples random start samples of len_block</p></li>
<li><p>Optionally detrend the data in time to remove power level trends</p></li>
<li><p>Use a robust measure to estimate the noise in each channel
Here we use IQR that is then scared</p></li>
<li><p>Optionally use a Median filter to filter channels that are
contaminated at at the 25th to 75th level</p></li>
<li><p>Add up these standard deviations to find the time series standard
deviations</p></li>
</ol>
<dl>
<dt>Args:</dt><dd><p>yr_object: your object for the file to process</p>
<p>num_samples: number of samples to take</p>
<p>detrend: detrend along the time axis before finding the dispersion</p>
<dl class="simple">
<dt>kernel_size: the kernel size for the median filter. If 0 or 1</dt><dd><p>no filter is applied</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Ideal standard deviation of time series,
Real standard deviation of the time series</p>
</dd>
<dt>Notes:</dt><dd><p>detrend would be useful if there are power level changes in the data. This will
cause the Standard deviation to be to high. This will remove random trends
as well, so this could lead to underestimating the noise level</p>
<p>IQR and MAD do a reasonable job at estimating the dispersion of a channel
as long as the channel is not filled with RFI. If there is RFI power
at all the percentiles this will cause the IQR to be too high,
so we use a median filter to remove these channels.
By using smallish blocks, we hope to avoid trends that can’t
be detrened linearly</p>
<p>By calculating all the channels independently, then adding the
standard deviations we should avoid correlated (zero dm)
noise that shows up across off the channels</p>
<p>Calculate the standard deviation of the zero dm time series by collapsing
all the channels for each random block. Then take the median of all these
standard deviations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.pad_along_axis">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">pad_along_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'middle'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.calculators.pad_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad along an axis.</p>
<dl>
<dt>args:</dt><dd><p>array: Array to pad</p>
<p>new_length: New length of the axis</p>
<p>axis: Axis to be padded</p>
<p>mode: mode to pad, see numpy.pad</p>
<dl class="simple">
<dt>location: Location of the pad. Options are</dt><dd><p>[end, start, middle]</p>
</dd>
<dt>return:</dt><dd><p>Array padded along <cite>axis</cite></p>
</dd>
</dl>
</dd>
</dl>
<p>Based on
<a class="reference external" href="https://stackoverflow.com/a/49766444">https://stackoverflow.com/a/49766444</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.preprocess">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">preprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">central_value_calc</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disperion_calc</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'std'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#jess.calculators.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocess the array for later statistical tests</p>
<dl>
<dt>Args:</dt><dd><p>data: 2D dynamic spectra to process</p>
<p>central_value_calc: The method to calculate the central value,</p>
<p>dispersion_calc: The method to calculate the dispersion</p>
</dd>
<dt>Returns:</dt><dd><p>data preprocessed along axis=0, axis=1</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.shannon_entropy">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">shannon_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.calculators.shannon_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Shannon Entropy along a given axis.</p>
<p>Return entropy in natural units.</p>
<dl>
<dt>Args:</dt><dd><p>data: 2D Array to calculate entropy</p>
<p>axis: axis to calculate entropy</p>
</dd>
<dt>Returns:</dt><dd><p>Shannon Entropy along an axis</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators.to_dtype">
<span class="sig-prename descclassname"><span class="pre">jess.calculators.</span></span><span class="sig-name descname"><span class="pre">to_dtype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.dtype</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.calculators.to_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a chunk of data and changes it to a given data type.</p>
<dl>
<dt>Args:</dt><dd><p>data: Array that you want to convert</p>
<p>dtype: The output data type</p>
</dd>
<dt>Returns:</dt><dd><p>data converted to dtype</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-jess.calculators_cupy">
<span id="jess-calculators-cupy-module"></span><h2>jess.calculators_cupy module<a class="headerlink" href="#module-jess.calculators_cupy" title="Permalink to this headline">¶</a></h2>
<p>The repository for all calculators</p>
<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators_cupy.closest_larger_factor">
<span class="sig-prename descclassname"><span class="pre">jess.calculators_cupy.</span></span><span class="sig-name descname"><span class="pre">closest_larger_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#jess.calculators_cupy.closest_larger_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the closest factor that is larger than a number.</p>
<dl>
<dt>args:</dt><dd><p>num: The number of to find the largest factor</p>
<p>factor: Factor to divide by</p>
</dd>
<dt>returns:</dt><dd><p>Closest factor of <cite>factor</cite> larger than <cite>num</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators_cupy.decimate">
<span class="sig-prename descclassname"><span class="pre">jess.calculators_cupy.</span></span><span class="sig-name descname"><span class="pre">decimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_factor:</span> <span class="pre">typing.Optional[int]</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_factor:</span> <span class="pre">typing.Optional[int]</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend:</span> <span class="pre">typing.Callable</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">mean&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.calculators_cupy.decimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes decimates along either/both time and frequency axes.
Flattens data along frequency before freqency decimation.
Fattens again in frequency before returning.</p>
<dl>
<dt>args:</dt><dd><p>dynamic_spectra: dynamic spectra with time on the ventricle axis</p>
<p>time_factor: factor to reduce time sampling by</p>
<p>freq_factor: factor to reduce freqency channels</p>
</dd>
<dt>returns:</dt><dd><p>Flattened in frequency dynamic spectra, reduced in time and/or freqency</p>
</dd>
<dt>notes:</dt><dd><p>Always uses jess.calculator_cupy.mean to add data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators_cupy.flattner_median">
<span class="sig-prename descclassname"><span class="pre">jess.calculators_cupy.</span></span><span class="sig-name descname"><span class="pre">flattner_median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_to:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_time_series:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intermediate_dtype:</span> <span class="pre">type</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">cupy._core.core.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#jess.calculators_cupy.flattner_median" title="Permalink to this definition">¶</a></dt>
<dd><p>This flattens the dynamic spectra by subtracting the medians of the time series
and then the medians of the of bandpass. Then add flatten_to to all the pixels
so that the data can be keep as the same data type.</p>
<dl>
<dt>args:</dt><dd><p>dynamic_spectra: The dynamic spectra you want to flatten</p>
<p>flatten_to: The number to set as the baseline</p>
<dl class="simple">
<dt>kernel_size: The size of the median filter to run over the medians</dt><dd><p>0,1 =&gt; nothing is applied</p>
</dd>
</dl>
<p>intermediate_dtype: the data type of the intermediate calculation</p>
<p>return_same_dtype: return the same data type as dynamic_spectra</p>
<dl class="simple">
<dt>return_time_series: return the time series difference from flatten_to</dt><dd><p>median_time_series - flatten_to</p>
</dd>
</dl>
</dd>
<dt>returns:</dt><dd><p>Dynamic spectra flattened in frequency and time
(optional) time series medians</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators_cupy.flattner_mix">
<span class="sig-prename descclassname"><span class="pre">jess.calculators_cupy.</span></span><span class="sig-name descname"><span class="pre">flattner_mix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra:</span> <span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_to:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_same_dtype:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_time_series:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intermediate_dtype:</span> <span class="pre">type</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">cupy._core.core.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#jess.calculators_cupy.flattner_mix" title="Permalink to this definition">¶</a></dt>
<dd><p>This flattens the dynamic spectra by subtracting the medians of the time series
and then the medians of the of bandpass. Then add flatten_to to all the pixels
so that the data can be keep as the same data type.</p>
<p>This uses medians subtraction on the time series. This is less agressive and
leaved the mean subtraction for the zero-dm.</p>
<p>Mean subtraction across the spectrum allows for smoother transition between blocks.</p>
<dl>
<dt>args:</dt><dd><p>dynamic_spectra: The dynamic spectra you want to flatten</p>
<p>flatten_to: The number to set as the baseline</p>
<dl class="simple">
<dt>kernel_size: The size of the median filter to run over the medians</dt><dd><p>0,1 =&gt; nothing is applied</p>
</dd>
<dt>return_same_dtype: return the same data type as given, else it will</dt><dd><p>at least np.int64</p>
</dd>
<dt>return_time_series: return the time series median differences from flatten_to</dt><dd><p>median_time_series - flatten_to</p>
</dd>
</dl>
</dd>
<dt>returns:</dt><dd><p>Dynamic spectra flattened in frequency and time
(optional) time series medians</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators_cupy.mean">
<span class="sig-prename descclassname"><span class="pre">jess.calculators_cupy.</span></span><span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'median'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.calculators_cupy.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the data along an axis by taking the mean of a ‘factor’ of rows along
the axis</p>
<dl>
<dt>args:</dt><dd><p>data_array: array of data to be reduces</p>
<p>factor: the factor to reduce the dimension by</p>
<p>axis: axis to operate on</p>
<dl class="simple">
<dt>pad: method to pad if axis is not divisible. If None</dt><dd><p>will not pad</p>
</dd>
</dl>
</dd>
<dt>returns:</dt><dd><p>array with axis reduced by factor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators_cupy.pad_along_axis">
<span class="sig-prename descclassname"><span class="pre">jess.calculators_cupy.</span></span><span class="sig-name descname"><span class="pre">pad_along_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'middle'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.calculators_cupy.pad_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad along an axis.</p>
<dl>
<dt>args:</dt><dd><p>array: Array to pad</p>
<p>new_length: New length of the axis</p>
<p>axis: Axis to be padded</p>
<p>mode: mode to pad, see numpy.pad</p>
<dl class="simple">
<dt>location: Location of the pad. Options are</dt><dd><p>[end, start, middle]</p>
</dd>
<dt>return:</dt><dd><p>Array padded along <cite>axis</cite></p>
</dd>
</dl>
</dd>
</dl>
<p>Based on
<a class="reference external" href="https://stackoverflow.com/a/49766444">https://stackoverflow.com/a/49766444</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.calculators_cupy.to_dtype">
<span class="sig-prename descclassname"><span class="pre">jess.calculators_cupy.</span></span><span class="sig-name descname"><span class="pre">to_dtype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.dtype</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.calculators_cupy.to_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a chunk of data and changes it to a given data type.</p>
<dl>
<dt>Args:</dt><dd><p>data: Array that you want to convert</p>
<p>dtype: The output data type</p>
</dd>
<dt>Returns:</dt><dd><p>data converted to dtype</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-jess.channel_masks">
<span id="jess-channel-masks-module"></span><h2>jess.channel_masks module<a class="headerlink" href="#module-jess.channel_masks" title="Permalink to this headline">¶</a></h2>
<p>Contains Utilities to make channel masks</p>
<dl class="py function">
<dt class="sig sig-object py" id="jess.channel_masks.channel_masker">
<span class="sig-prename descclassname"><span class="pre">jess.channel_masks.</span></span><span class="sig-name descname"><span class="pre">channel_masker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'median_fitter'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flagger</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'z_score_flagger'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_above</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_below</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_clust_frac</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_plots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.channel_masks.channel_masker" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the given statistical test on a given data array.
Then a curve is fitted to the resulting test-bandpass, this removes large effects
of the receiver. Z-scores are calculated and channels that decide
x-score*sigma are flagged.</p>
<p>The mask of the outlying channels is then saved.</p>
<p>One should be careful if there are only a few channels, z-score will be
a bad way to look for outliers.</p>
<dl>
<dt>args:</dt><dd><p>file - dynamic spectra, the 2D chunk of data to process, time is on y-axis</p>
<dl>
<dt>test - Statistical test you preform on each channel,</dt><dd><p>option are from stat_test and are
Measures of scale: [98-2, 91-9, 90-10, 75-25, mad, stand-dev]
Guassianity: [anderson-darling, d’angostino, jarque-bera,</p>
<blockquote>
<div><p>kurtosis, lilliefors, shapio-wilk, skew]</p>
</div></blockquote>
<p>Entropy: [shannon-entropy]
Central Value: [mean, midhing, trimean]</p>
<p>If you give a list of two tests, you will get the first one
subtracted from the second. For example (stand-dev, mad)
will be a test the difference between the two.</p>
<p>You can your rfi_viewer.py to see how your data looks at each
one of these tests</p>
</dd>
<dt>sigma - This routine calculates z values over all channels, this is the</dt><dd><p>sigma at which to flag channels</p>
</dd>
</dl>
<p>start - Sample at which to start (default: beginning of file)</p>
<dl class="simple">
<dt>nspectra - the number of spectra to process</dt><dd><p>(default: 65536, the default heimdall gulp)</p>
</dd>
</dl>
<p>fitter - Fitter used to fit bandpass effects</p>
<dl class="simple">
<dt>chans_per_fit - the number of channels per fitting point, see fitters.py</dt><dd><p>If zero, don’t do bandpass subtraction.
If two tests are given, smooth the second test. (default: 30)</p>
</dd>
<dt>flagger: The flagger to remove outlying points,</dt><dd><p>[z_score_flagger, dbscan_flagger]</p>
</dd>
</dl>
<p>flag_upper - flag values above median+sigma*standard dev (Only z-score)</p>
<p>flag_lower - flag values below median - sigma*standard dev (Only z-score)</p>
<p>eps - dbscan eps (dbscan only)</p>
<p>min_clust_frac - fraction of channels for the minimum cluster size (dbscan only)</p>
<dl class="simple">
<dt>show_plot - show the fit and threshold plots, used to check if data is</dt><dd><p>well behaved (default: false)</p>
</dd>
</dl>
</dd>
<dt>returns:</dt><dd><p>mask - ndarray[bools], where <cite>True</cite> is a bad channel</p>
</dd>
<dt>Example:</dt><dd><p>yr_obj = Your(‘some_data.fil’)
dynamic_spectra = yr_obj.get_data(0, 65536)
mask = channel_masker(dynamic_spectra, which_test=”mean”)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.channel_masks.dbscan_flagger">
<span class="sig-prename descclassname"><span class="pre">jess.channel_masks.</span></span><span class="sig-name descname"><span class="pre">dbscan_flagger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_values</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_clust_frac</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.14</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_plot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.channel_masks.dbscan_flagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Use DBScan to look for outliers</p>
<dl>
<dt>args:</dt><dd><dl class="simple">
<dt>test_values: Values from some test for each channel,</dt><dd><p>expects bandpass effects to be subtracted off</p>
</dd>
</dl>
<p>chans: list of chan numbers</p>
<p>eps: DBSCAN eps</p>
<p>min_clust_fraction: minimum fraction of channels for a DBSCAN cluster</p>
<p>show_plot: show diagnostic plot of cluster</p>
</dd>
<dt>return:</dt><dd><p>Bool mask, True=Bad channel</p>
</dd>
<dt>Example:</dt><dd><p>yr = Your(“some.fil”)
dynamic_spectra = yr.get_data(7000, 2 ** 17)
test_values = stat_test(dynamic_spectra, test)
fit = fitter(test_values, chans_per_fit=chans_per_fit)
flat = test_values - fit
mask = dbscan_flagger(flat)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.channel_masks.stat_test">
<span class="sig-prename descclassname"><span class="pre">jess.channel_masks.</span></span><span class="sig-name descname"><span class="pre">stat_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">which_test</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.channel_masks.stat_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the statistical tests
Should have the same tests as rfi_viewer.py
Test:</p>
<blockquote>
<div><p>Measures of scale:  98-2, 91-9, 90-10, 75-25, mad, stand-dev
Gaussianity: anderson-darling, d’angostino, jarque-bera,</p>
<blockquote>
<div><p>lilliefors, kurtosis, shapiro-wilk, skew</p>
</div></blockquote>
<p>Central Tendency: mean, midhing, trimean
Information: shannopn-entropy</p>
</div></blockquote>
<p>MAD and IQR report the scaled version, to make comparison tests easier</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.channel_masks.z_score_flagger">
<span class="sig-prename descclassname"><span class="pre">jess.channel_masks.</span></span><span class="sig-name descname"><span class="pre">z_score_flagger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flat_bandpass:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_above:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_below:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_of_scale:</span> <span class="pre">typing.Callable</span> <span class="pre">=</span> <span class="pre">functools.partial(&lt;function</span> <span class="pre">median_abs_deviation&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale='normal')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_plots:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.channel_masks.z_score_flagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags points based on z-score</p>
<dl>
<dt>args:</dt><dd><p>flat_banpass - Results of some statistical test with the banpass effects removed</p>
<p>flag_above - Flag values with a z-scores above the threshold</p>
<p>flag_below - Flag values with a z-score below the threshold</p>
<p>sigma - the standard deviation to flag points</p>
<p>show_plots - Show diagnostic plots</p>
</dd>
<dt>returns:</dt><dd><p>Bool mask where True = bad data</p>
</dd>
<dt>Example:</dt><dd><p>yr = Your(“some.fil”)
dynamic_spectra = yr.get_data(7000, 2 ** 17)
test_values = stat_test(dynamic_spectra, test)
fit = fitter(test_values, chans_per_fit=chans_per_fit)
flat = test_values - fit
mask = z_score_flagger(flat)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-jess.dispersion">
<span id="jess-dispersion-module"></span><h2>jess.dispersion module<a class="headerlink" href="#module-jess.dispersion" title="Permalink to this headline">¶</a></h2>
<p>Dispersion Utilities</p>
<p>dedisperse</p>
<dl class="py function">
<dt class="sig sig-object py" id="jess.dispersion.calc_dispersion_delays">
<span class="sig-prename descclassname"><span class="pre">jess.dispersion.</span></span><span class="sig-name descname"><span class="pre">calc_dispersion_delays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chan_freqs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.dispersion.calc_dispersion_delays" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates dispersion delays at an input DM and a frequency array.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dm (float): DM to calculate the delay
chan_freqs (float): Frequencies</p>
</dd>
<dt>Returns:</dt><dd><p>delays (float): dispersion delays at each frequency channel
(in seconds)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.dispersion.dedisperse">
<span class="sig-prename descclassname"><span class="pre">jess.dispersion.</span></span><span class="sig-name descname"><span class="pre">dedisperse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tsamp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chan_freqs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delays</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.dispersion.dedisperse" title="Permalink to this definition">¶</a></dt>
<dd><p>Dedisperse a chunk of data..</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Our method rolls the data around while dedispersing it.</p>
</dd>
<dt>Args:</dt><dd><p>data: data to dedisperse
dm (float): The DM to dedisperse the data at.
chan_freqs (float): frequencies
tsamp (float): sampling time in seconds
delays (float): dispersion delays for each channel (in seconds)</p>
</dd>
<dt>Returns:</dt><dd><p>dedispersed (float): Dedispersed data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.dispersion.delay_lost">
<span class="sig-prename descclassname"><span class="pre">jess.dispersion.</span></span><span class="sig-name descname"><span class="pre">delay_lost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chan_freqs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tsamp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.int64</span></span></span><a class="headerlink" href="#jess.dispersion.delay_lost" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the maximum dispersion delay in number of samples</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.dispersion.fdmt">
<span class="sig-prename descclassname"><span class="pre">jess.dispersion.</span></span><span class="sig-name descname"><span class="pre">fdmt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.dtype</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.dispersion.fdmt" title="Permalink to this definition">¶</a></dt>
<dd><p>This function implements the  FDMT algorithm.
Note that the bandpass must be flipped, and time
on the horizontal</p>
<dl>
<dt>Args:</dt><dd><p>dynamic_spectra - Dynamic Spectra to dedisperse</p>
<dl class="simple">
<dt>f_min,f_max are the base-band begin and end frequencies.</dt><dd><p>The frequencies should be entered in MHz</p>
</dd>
<dt>max_dt - the maximal delay (in time bins) of the maximal dispersion.</dt><dd><p>Appears in the paper as N_{Delta}
A typical input is maxDT = N_f</p>
</dd>
<dt>dtype - a valid numpy dtype.</dt><dd><p>reccomended: either int32, or int64.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The dispersion measure transform of the Input matrix.
he output dimensions are [Input.shape[1],maxDT]</p>
</dd>
</dl>
<p>For details, see algorithm 1 in Zackay &amp; Ofek (2014)
See the Lincense in _fdmt_utils.py</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.dispersion.fdmt_fft">
<span class="sig-prename descclassname"><span class="pre">jess.dispersion.</span></span><span class="sig-name descname"><span class="pre">fdmt_fft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamic_spectra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.dtype</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.dispersion.fdmt_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>This function implements the  FDMT-FFT algorithm.</p>
<dl>
<dt>Args:</dt><dd><p>dynamic_spectra -</p>
<dl class="simple">
<dt>f_min,f_max - are the base-band begin and end frequencies.</dt><dd><p>he frequencies can be entered in both MHz and GHz, units
are factored out in all uses.</p>
</dd>
<dt>maxDT - The maximal delay (in time bins) of the maximal dispersion.</dt><dd><p>Appears in the paper as N_{Delta}
A typical input is maxDT = N_f</p>
</dd>
<dt>dtype - To naively use FFT, one must use floating point types.</dt><dd><p>Due to casting, use either complex64 or complex128.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The dispersion measure transform of the Input matrix.
The output dimensions are [Input.shape[1],maxDT]</p>
</dd>
</dl>
<p>For details, see algorithm 2 in Zackay &amp; Ofek (2014)
See the Lincense in _fdmt_utils.py</p>
</dd></dl>

</section>
<section id="module-jess.dispersion_cupy">
<span id="jess-dispersion-cupy-module"></span><h2>jess.dispersion_cupy module<a class="headerlink" href="#module-jess.dispersion_cupy" title="Permalink to this headline">¶</a></h2>
<p>Dispersion Utilities using cupy</p>
<dl class="py function">
<dt class="sig sig-object py" id="jess.dispersion_cupy.calc_dispersion_delays">
<span class="sig-prename descclassname"><span class="pre">jess.dispersion_cupy.</span></span><span class="sig-name descname"><span class="pre">calc_dispersion_delays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chan_freqs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.dispersion_cupy.calc_dispersion_delays" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates dispersion delays at an input DM and a frequency array.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dm (float): DM to calculate the delay
chan_freqs (float): Frequencies</p>
</dd>
<dt>Returns:</dt><dd><p>delays (float): dispersion delays at each frequency channel
(in seconds)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.dispersion_cupy.dedisperse">
<span class="sig-prename descclassname"><span class="pre">jess.dispersion_cupy.</span></span><span class="sig-name descname"><span class="pre">dedisperse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tsamp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chan_freqs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">cupy._core.core.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delays</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">cupy._core.core.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.dispersion_cupy.dedisperse" title="Permalink to this definition">¶</a></dt>
<dd><p>Dedisperse a chunk of data..</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Our method rolls the data around while dedispersing it.</p>
</dd>
<dt>Args:</dt><dd><p>data: data to dedisperse
dm (float): The DM to dedisperse the data at.
chan_freqs (float): frequencies
tsamp (float): sampling time in seconds
delays (float): dispersion delays for each channel (in seconds)</p>
</dd>
<dt>Returns:</dt><dd><p>dedispersed (float): Dedispersed data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.dispersion_cupy.delay_lost">
<span class="sig-prename descclassname"><span class="pre">jess.dispersion_cupy.</span></span><span class="sig-name descname"><span class="pre">delay_lost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chan_freqs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tsamp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.int64</span></span></span><a class="headerlink" href="#jess.dispersion_cupy.delay_lost" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the maximum dispersion delay in number of samples</p>
</dd></dl>

</section>
<section id="module-jess.fitters">
<span id="jess-fitters-module"></span><h2>jess.fitters module<a class="headerlink" href="#module-jess.fitters" title="Permalink to this headline">¶</a></h2>
<p>A somewhat robust way to fit bandpasses</p>
<p>cheb_fitter() Fits Chebyshev polynomials, does to fits to be
robust.</p>
<p>bandpass_fitter() Fits polynomials twice to get a robust fit.</p>
<p>bspline_fitt() Fits bsplines using the Huber Regressor
as a loss function</p>
<p>bspline_fitter() Fits bsplines using the Huber Regressor
as a loss function, fits twice to be even more robust</p>
<dl class="py class">
<dt class="sig sig-object py" id="jess.fitters.SplineTransformer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jess.fitters.</span></span><span class="sig-name descname"><span class="pre">SplineTransformer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">knots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.fitters.SplineTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>The bspline transformer class</p>
<dl class="py method">
<dt class="sig sig-object py" id="jess.fitters.SplineTransformer.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.fitters.SplineTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>This gives sklearn a fit function</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jess.fitters.SplineTransformer.get_empty_bsplines">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_empty_bsplines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_knots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_chans</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#jess.fitters.SplineTransformer.get_empty_bsplines" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the empty bsplines that will be
used then fit by the Huber Regressor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jess.fitters.SplineTransformer.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jess.fitters.SplineTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the bsplines</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters.arpls_fitter">
<span class="sig-prename descclassname"><span class="pre">jess.fitters.</span></span><span class="sig-name descname"><span class="pre">arpls_fitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass:</span> <span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">10000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itermax:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype:</span> <span class="pre">object</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.fitters.arpls_fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Baseline correction using asymmetrically
reweighted penalized least squares smoothing
Sung-June Baek, Aaron Park, Young-Jin Ahna and Jaebum Choo,
Analyst, 2015, 140, 250 (2015)</p>
<p>Abstract</p>
<p>Baseline correction methods based on penalized least squares are successfully
applied to various spectral analyses. The methods change the weights iteratively
by estimating a baseline. If a signal is below a previously fitted baseline,
large weight is given. On the other hand, no weight or small weight is given
when a signal is above a fitted baseline as it could be assumed to be a part
of the peak. As noise is distributed above the baseline as well as below the
baseline, however, it is desirable to give the same or similar weights in
either case. For the purpose, we propose a new weighting scheme based on the
generalized logistic function. The proposed method estimates the noise level
iteratively and adjusts the weights correspondingly. According to the
experimental results with simulated spectra and measured Raman spectra, the
proposed method outperforms the existing methods for baseline correction and
peak height estimation.</p>
<p>This was first used for radio astronomy in
Radio frequency interference mitigation based on the asymmetrically reweighted
penalized least squares and SumThreshold method (2021)
<a class="reference external" href="http://zmtt.bao.ac.cn/GPPS/RFI/">http://zmtt.bao.ac.cn/GPPS/RFI/</a></p>
<dl>
<dt>Args:</dt><dd><p>Bandpass: the bandpass to fit</p>
<dl class="simple">
<dt>lam: parameter that can be adjusted by user. The larger lambda is,</dt><dd><p>the smoother the resulting background, z</p>
</dd>
<dt>ratio: weighting deviations: 0 &lt; ratio &lt; 1,</dt><dd><p>smaller values allow less negative values</p>
</dd>
</dl>
<p>itermax: number of iterations to perform</p>
<p>dtype: data type to preform the matrix opterations</p>
</dd>
<dt>Output:</dt><dd><p>Fit to bandpass</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters.bspline_fit">
<span class="sig-prename descclassname"><span class="pre">jess.fitters.</span></span><span class="sig-name descname"><span class="pre">bspline_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_knot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.fitters.bspline_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>This fits a bsplines using the Huber regressor.</p>
<p>The Huber Regressor is a robust fitting function.</p>
<p>Inspired by <a class="reference external" href="https://gist.github.com/MMesch/35d7833a3daa4a9e8ca9c6953cbe21d4">https://gist.github.com/MMesch/35d7833a3daa4a9e8ca9c6953cbe21d4</a></p>
<dl>
<dt>Args:</dt><dd><p>Bandpass: the bandpass to fit</p>
<p>chans_per_knot: number of channels per spline knot</p>
<p>max_iter: The maximum number of iterations</p>
</dd>
<dt>Returns:</dt><dd><p>Fit to bandpass</p>
</dd>
<dt>Example:</dt><dd><p>yr = Your(input_file)
data = yr.get_data(0, 8192)
bandpass = np.median(section, axis=0)
fit = bspline_fit(bandpass)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters.bspline_fitter">
<span class="sig-prename descclassname"><span class="pre">jess.fitters.</span></span><span class="sig-name descname"><span class="pre">bspline_fitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.fitters.bspline_fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>This fits a bsplines using the Huber regressor.</p>
<p>The Huber Regressor is a robust fitting function.</p>
<p>This wraps bspline_fit, # running it twice to help it futher reject outliers
(Not implemented)</p>
<dl>
<dt>Args:</dt><dd><p>Bandpass: the bandpass to fit</p>
<p>chans_per_fit: number of channels per spline knot</p>
</dd>
<dt>Returns:</dt><dd><p>Fit to bandpass</p>
</dd>
<dt>Example:</dt><dd><p>yr = Your(input_file)
data = yr.get_data(0, 8192)
bandpass = np.median(section, axis=0)
fit = bspline_fitter(bandpass)</p>
</dd>
<dt>Notes:</dt><dd><p>I’ve attempted to make this even more robbust by running it once, flagging data
and running it again. However I can’t get model.predict() to work on the full
channel set when it is trained with flagged channels.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters.cheb_fitter">
<span class="sig-prename descclassname"><span class="pre">jess.fitters.</span></span><span class="sig-name descname"><span class="pre">cheb_fitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.fitters.cheb_fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits bandpasses by Chebyshev fitting the bandpass, looking for channels that
are far from this fit, excluding these channels and refitting the bandpass
This works well for bandpasses with sine/cosine like features.</p>
<dl>
<dt>Args:</dt><dd><p>bandpass: the bandpass to fit</p>
<p>chans_per_fit: number of channels for each polynomial order</p>
<p>mask_sigma: standard deviation at which to mask outlying channels</p>
</dd>
<dt>Returns:</dt><dd><p>Fit to bandpass</p>
</dd>
<dt>Example:</dt><dd><p>yr = Your(input_file)
data = yr.get_data(0, 8192)
bandpass = np.median(section, axis=0)
fit = cheb_fitter(bandpass)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters.get_fitter">
<span class="sig-prename descclassname"><span class="pre">jess.fitters.</span></span><span class="sig-name descname"><span class="pre">get_fitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span></span></span><a class="headerlink" href="#jess.fitters.get_fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the fitter object for a given string</p>
<dl class="simple">
<dt>Args:</dt><dd><p>fitter: string with the selection of
bspline_fitter, cheb_fitter, median_fitter, or poly_fitter</p>
</dd>
<dt>return:</dt><dd><p>corresponding fitter object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters.median_fitter">
<span class="sig-prename descclassname"><span class="pre">jess.fitters.</span></span><span class="sig-name descname"><span class="pre">median_fitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">19</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.fitters.median_fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses a median filter to fit for the bandpass shape</p>
<dl>
<dt>Args:</dt><dd><p>bandpass: ndarray to fit</p>
<p>chans_per_fit: Number of channels to run the median filter over</p>
<dl class="simple">
<dt>iterations: Number of iterations to run the median filter. Must be</dt><dd><p>greater that one.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Fit to bandpass</p>
</dd>
<dt>Notes:</dt><dd><p>The idea to run this multiple times is from GSL.
A recursive median filter might be worth investigating.
See <a class="reference external" href="https://www.gnu.org/software/gsl/doc/html/filter.html">https://www.gnu.org/software/gsl/doc/html/filter.html</a></p>
</dd>
<dt>Example:</dt><dd><p>yr = Your(input_file)
data = yr.get_data(0, 8192)
bandpass = np.median(section, axis=0)
fit = median_fitter(bandpass)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters.poly_fitter">
<span class="sig-prename descclassname"><span class="pre">jess.fitters.</span></span><span class="sig-name descname"><span class="pre">poly_fitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#jess.fitters.poly_fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits bandpasses by polyfitting the bandpass, looking for channels that
are far from this fit, excluding these channels and refitting the bandpass</p>
<dl>
<dt>Args:</dt><dd><p>bandpass: the bandpass to fit</p>
<p>channels: list of channel numbers, if None, will create a list starting at zero</p>
<p>chans_per_fit: Number of channels per polynomial</p>
<p>mask_sigma: standard deviation at which to mask outlying channels</p>
</dd>
<dt>Returns:</dt><dd><p>Fit to bandpass</p>
</dd>
<dt>Example:</dt><dd><p>yr = Your(input_file)
data = yr.get_data(0, 8192)
bandpass = np.median(section, axis=0)
fit = poly_fitter(bandpass)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-jess.fitters_cupy">
<span id="jess-fitters-cupy-module"></span><h2>jess.fitters_cupy module<a class="headerlink" href="#module-jess.fitters_cupy" title="Permalink to this headline">¶</a></h2>
<p>A somewhat robust way to fit bandpasses - cupy edition</p>
<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters_cupy.arpls_fitter">
<span class="sig-prename descclassname"><span class="pre">jess.fitters_cupy.</span></span><span class="sig-name descname"><span class="pre">arpls_fitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass:</span> <span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">30000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itermax:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype:</span> <span class="pre">object</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.fitters_cupy.arpls_fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Baseline correction using asymmetrically
reweighted penalized least squares smoothing
Sung-June Baek, Aaron Park, Young-Jin Ahna and Jaebum Choo,
Analyst, 2015, 140, 250 (2015)</p>
<p>Abstract</p>
<p>Baseline correction methods based on penalized least squares are successfully
applied to various spectral analyses. The methods change the weights iteratively
by estimating a baseline. If a signal is below a previously fitted baseline,
large weight is given. On the other hand, no weight or small weight is given
when a signal is above a fitted baseline as it could be assumed to be a part
of the peak. As noise is distributed above the baseline as well as below the
baseline, however, it is desirable to give the same or similar weights in
either case. For the purpose, we propose a new weighting scheme based on the
generalized logistic function. The proposed method estimates the noise level
iteratively and adjusts the weights correspondingly. According to the
experimental results with simulated spectra and measured Raman spectra, the
proposed method outperforms the existing methods for baseline correction and
peak height estimation.</p>
<p>This was first used for radio astronomy in
Radio frequency interference mitigation based on the asymmetrically reweighted
penalized least squares and SumThreshold method (2021)
<a class="reference external" href="http://zmtt.bao.ac.cn/GPPS/RFI/">http://zmtt.bao.ac.cn/GPPS/RFI/</a></p>
<dl>
<dt>Args:</dt><dd><p>Bandpass: the bandpass to fit</p>
<dl class="simple">
<dt>lam: parameter that can be adjusted by user. The larger lambda is,</dt><dd><p>the smoother the resulting background, z</p>
</dd>
<dt>ratio: weighting deviations: 0 &lt; ratio &lt; 1,</dt><dd><p>smaller values allow less negative values</p>
</dd>
</dl>
<p>itermax: number of iterations to perform</p>
<p>dtype: data type to preform the matrix opterations</p>
</dd>
<dt>Output:</dt><dd><p>Fit to bandpass</p>
</dd>
<dt>Note:</dt><dd><p>The Cholesky decomosition on cupy (9.5.0) is slightly off (at e-9 level)
this causes the changes amount of smoothness. Upping lam to
3e4 makes the outputs the same.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters_cupy.median_fitter">
<span class="sig-prename descclassname"><span class="pre">jess.fitters_cupy.</span></span><span class="sig-name descname"><span class="pre">median_fitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">19</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.fitters_cupy.median_fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses a median filter to fit for the bandpass shape.
Note: does inplace</p>
<dl>
<dt>Args:</dt><dd><p>bandpass: ndarray to fit</p>
<p>chans_per_fit: Number of channels to run the median filter over</p>
<dl class="simple">
<dt>iterations: Number of iterations to run the median filter. Must be</dt><dd><p>greater that one.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Fit to bandpass</p>
</dd>
<dt>Notes:</dt><dd><p>The idea to run this multiple times is from GSL.
A recursive median filter might be worth investigating.
See <a class="reference external" href="https://www.gnu.org/software/gsl/doc/html/filter.html">https://www.gnu.org/software/gsl/doc/html/filter.html</a></p>
</dd>
<dt>Example:</dt><dd><p>yr = Your(input_file)
data = yr.get_data(0, 8192)
bandpass = np.median(section, axis=0)
fit = median_fitter(bandpass)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="jess.fitters_cupy.poly_fitter">
<span class="sig-prename descclassname"><span class="pre">jess.fitters_cupy.</span></span><span class="sig-name descname"><span class="pre">poly_fitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cupy._core.core.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">cupy._core.core.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chans_per_fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cupy._core.core.ndarray</span></span></span><a class="headerlink" href="#jess.fitters_cupy.poly_fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits bandpasses by polyfitting the bandpass, looking for channels that
are far from this fit, excluding these channels and refitting the bandpass</p>
<dl>
<dt>Args:</dt><dd><p>bandpass: the bandpass (or any array) that you want to fit a polynomial to.</p>
<p>channels: list of channel numbers, if None, will create a list starting at zero</p>
<p>bandpass: the bandpass to fit</p>
<p>polyorder: order of polynomial to fit</p>
<p>mask_sigma: standard deviation at which to mask outlying channels</p>
</dd>
<dt>Returns:</dt><dd><p>Fit to bandpass</p>
</dd>
<dt>Example:</dt><dd><p>yr = Your(input_file)
data = cp.asarray(yr.get_data(0, 8192))
bandpass = cp.median(section, axis=0)
fit = poly_fitter(bandpass)
plt.plot(fit.get())</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-jess">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-jess" title="Permalink to this headline">¶</a></h2>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">jess</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">JESS - Just in Time Elimination of Spurious Signals</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html#overview">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html#questions-contributing">Questions + Contributing</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Joseph W Kania.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/jess.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>